#include "../defMacro.h"
#include "../huckel/header.h"
#include "../algebra_real/algebra.h"




///////////////////////////////////////////////////////////////////////////////////////////////////
//			WRITE THE MO FILE QCHEM STYLE
///////////////////////////////////////////////////////////////////////////////////////////////////

void computeMO(double *H, double *S, atom *molecule, int nb_atom, int nb_orb, char *orb_elec, char *use_overlap, char *file_name)
{
  int i,j,k;
  FILE *f;
  FILE *fAtm;
  double D = 1.;
  int nbElec = 0;
  int nb_OQP;
  double *VECT_PRP, *VAL_PRP,*VP_TR,*val_prp;
  int nb_orb_tot;
  char atmFile[100];
  char stratm[100];
  ORB *orbitale;
  
  // alloc memory
  VECT_PRP = calloc(nb_orb*nb_orb,sizeof(double));
  VAL_PRP = calloc(nb_orb,sizeof(double));
  VP_TR = calloc(nb_orb*nb_orb,sizeof(double));  
  
  // determnine nb tot of orbitale
  // double the # os orb of all atm exept H and He
  nb_orb_tot = nb_orb;
  for(i=0;i<nb_atom;i++)
  {
    if(molecule[i].atomtype > 3)
      nb_orb_tot++;
  }
  
  // compute the number of electron
  for(i=0;i<nb_atom;i++)
  {
    nbElec += molecule[i].atomtype;
    if(molecule[i].atomtype>2)
      nbElec -=  2;
    if(molecule[i].atomtype>10)
      nbElec -=  7;
    
    
//     printf("atom = %d   ",molecule[i].atomtype);
//     printf("nbE = %d\n",nbElec);
  }
  nb_OQP = nbElec/2;
//   printf("nbELEC = %d, nbOQP = %d\n",nbElec,nb_OQP);
  
  // open the file
  f = fopen(file_name,"w");
  if(!f) 
  {
      printf("couldn't read %s\n",file_name);
      exit(1);
  }
  
  // diagonalise the Hamiltonian
  if(!strcmp(use_overlap,"no"))
  {
    spec(VECT_PRP, VAL_PRP, H, nb_orb);
    transMat_real(VP_TR, VECT_PRP, nb_orb);
  }
  
  if(!strcmp(use_overlap,"yes"))
  {
    val_prp = calloc(nb_orb,sizeof(double));
    spec_pencil(VECT_PRP, val_prp, H, S, nb_orb);
    cblas_dcopy(nb_orb,val_prp,1,VAL_PRP,1);
    qsort(VAL_PRP, nb_orb, sizeof(double), compare_doubles);
    reorder_vect_prp(VECT_PRP,VAL_PRP,val_prp,nb_orb);
    print_vect(VAL_PRP,nb_orb,"VP");
    transMat_real(VP_TR, VECT_PRP, nb_orb);
    free(val_prp);
  }
  
 
  // read the atomic parameter
  read_atomic_parameters(orb_elec);
   
  // determine the orbitale informations
  orbitale = calloc(nb_orb,sizeof(ORB));
  orbitale_information(orbitale, molecule, nb_atom, nb_orb, orb_elec);
  
  
  // debug print
  if (0) 
  {
  for(i=0;i<nb_orb;i++)
    printf("orb[%d].atm = %s\t orb[%d].atmNbr = %d\t orb[%d].type = %s\n",i,orbitale[i].atm,i,orbitale[i].atmNbr,i,orbitale[i].type);
    print_vect(VAL_PRP,nb_orb,"VP");
    print_mat(VECT_PRP,nb_orb,nb_orb,"VP");
  }
  
  
  ///////////////////////////////////////////////////////////////////////////////
  //		WRITE THE FILE QCHEM STYLE
  ///////////////////////////////////////////////////////////////////////////////
  
  fprintf(f,"                  Welcome to Q-Chem\n");
  fprintf(f," ----------------------------------------------------\n");
  fprintf(f,"      Standard Nuclear Orientation (Angstroms)\n");
  fprintf(f,"    I     Atom         X            Y            Z\n");
  fprintf(f," ----------------------------------------------------\n");
  for(i=0;i<nb_atom;i++)
    fprintf(f,"%5d\t  %2s      % 2.6f    % 2.6f    % 2.6f\n",i+1,molecule[i].atomTypeChar,molecule[i].x*D,molecule[i].y*D,molecule[i].z*D);
  fprintf(f," ----------------------------------------------------\n"); 
  fprintf(f,"Basis set in general basis input format:\n");
  fprintf(f," ----------------------------------------------------\n$basis\n");
  for(i=0;i<nb_atom;i++)
  {
    strcpy(atmFile,"/home/nico/Bureau/husky.1/SRC/basis/");
    strcat(atmFile,molecule[i].atomTypeChar);
    fAtm = fopen(atmFile,"r");
    if (!fAtm) 
    {
      printf("couldn't read %s\n",atmFile);
      exit(1);
    }
    while( fgets(stratm,sizeof(stratm),fAtm)!= NULL )
    {
      fputs (stratm,f);
    }
    fprintf(f,"****\n");
    fclose(fAtm);
  }
  fprintf(f,"$end\n");
  fprintf(f,"-----------------------------------------------------------------------\n");
  fprintf(f," There are %d shells and %d basis functions\n",nb_atom,nb_orb_tot);
  fprintf(f,"--------------------------------------------------------------\n");
  fprintf(f,"                  Orbital Energies (a.u.)\n");
  fprintf(f,"--------------------------------------------------------------\n\n");
  fprintf(f," Alpha MOs\n -- Occupied --\n");
  j = 0;
  for(i=0;i<nb_OQP;i++)
  { 
      if(VAL_PRP[i]<-10.)
	fprintf(f,"% 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<0.)
	fprintf(f," % 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<10.)
	fprintf(f," % 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<100.)
	fprintf(f,"  % 3.3f ",VAL_PRP[i]);
      
      j++;
      if(j>7){
	fprintf(f,"\n");
	j = 0;
      }
   }
   if(j>0)
     fprintf(f,"\n");
   fprintf(f," -- Virtual --\n");
   j = 0;
   for(i=nb_OQP;i<nb_orb;i++)
   { 
     
      if(VAL_PRP[i]<-10.)
	fprintf(f,"% 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<0.)
	fprintf(f," % 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<10.)
	fprintf(f," % 3.3f ",VAL_PRP[i]);
      else if(VAL_PRP[i]<100.)
	fprintf(f,"% 3.3f ",VAL_PRP[i]);
      
      j++;
      if(j>7){
	fprintf(f,"\n");
	j = 0;
      }
   }
   if(j>0)
     fprintf(f,"\n");
   fprintf(f," --------------------------------------------------------------\n");
   fprintf(f,"\n\n                        RESTRICTED (RHF) MOLECULAR ORBITAL COEFFICIENTS\n");
   i = 0;
   while(i<nb_orb-6)  
   {
    fprintf(f,"                        %2d        %2d        %2d        %2d        %2d        %2d\n",i+1,i+2,i+3,i+4,i+5,i+6);
    fprintf(f," eigenvalues:\t     % 2.3f   % 2.3f   % 2.3f   % 2.3f   % 2.3f   % 2.3f\n",VAL_PRP[i],VAL_PRP[i+1],VAL_PRP[i+2],VAL_PRP[i+3],VAL_PRP[i+4],VAL_PRP[i+5]);
    k = 1;
    for(j=0;j<nb_orb;j++) {
      if(!strcmp(orbitale[j].type,"s") && orbitale[j].atm_index_table > 3)
      {
	fprintf(f,"%4d  %s %-3d %s\t    % 1.5f  % 1.5f  % 1.5f  % 1.5f  % 1.5f  % 1.5f\n",
	      k,orbitale[j].atm,orbitale[j].atmNbr,orbitale[j].type,
              0.0,0.0,0.0,0.0,0.0,0.0);
	k++;
      }

      fprintf(f,"%4d  %s %-3d %s\t    % 1.5f  % 1.5f  % 1.5f  % 1.5f  % 1.5f  % 1.5f\n",
	      k,orbitale[j].atm,orbitale[j].atmNbr,orbitale[j].type,
              VP_TR[j*nb_orb+i],VP_TR[j*nb_orb+i+1],VP_TR[j*nb_orb+i+2],
	      VP_TR[j*nb_orb+i+3],VP_TR[j*nb_orb+i+4],VP_TR[j*nb_orb+i+5]);
      k++;
    }
    i += 5;
   }
   fprintf(f,"\n\n\n");
   
   // close file
   fclose(f);
   
   // free memory
   free(VAL_PRP);
   free(VP_TR);
   free(VECT_PRP);
   free(orbitale);
}
  

